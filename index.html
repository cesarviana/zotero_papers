<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/semantic-ui@2.3.1/dist/semantic.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jqcloud2@2.0.3/dist/jqcloud.min.css">
    <title>Acadêmic Papers</title>
    <style>
        @media (max-width: 360px) {
            #cloud {
                margin: 0 auto;
                width: 100%;
                height: 40vw;
            }

            .container {
                padding: 0;
                margin: 0;
            }

            div.input,
            input {
                width: 100%;
            }

            .publications,
            .segment {
                padding: 0 !important;
            }
        }

        .segment {
            min-height: 70px;
        }

        .publication-types {
            display: flex;
        }

        .publications {
            padding: 1vw;
        }

        .publication {
            margin: 0 0 .5vw .5vw;
            padding: 1vw;
            border-radius: 1vw;
            width: 100% !important;
        }

        h2 {
            margin-top: 2vw !important;
        }
        
        h3 {
            margin-bottom: 5px;
        }
        
        @media (min-width: 720px) {
            
            #cloud {
                margin: 0 auto;
                height: 15vw;
            }
            
            .years {
                display: flex;
            }
            
            .buttons {
                margin-top: 0;
                margin-bottom: 1.5vw;
                display: flex;
                justify-content: space-between;
            }

            .buttons .button {
                flex-grow: 1;
                display: flex;
                align-items: center;
                justify-content: center;
            }

        }

        .conferencePaper {
            background: #E7F2F8 !important
        }

        .journalArticle {
            background: #fbfbe8 !important
        }

        .book {
            background: #91d6e4 !important
        }

        .bookSection {
            background: #EFE7BC !important
        }

        .thesis {
            background: #facfd4 !important
        }

        .blogPost {
            background: #dffff0 !important
        }
    </style>
</head>

<body>
    <div id="app">

        <div id="cloud"></div>

        {{ filteringProject ? cache[selectedProject.key].start : '' }}

        <div class="ui form">
            <div class="three fields">
            
                <div class="field">

                    <select name="project" id="project" v-model="selectedProject" @change="loadPublications(replacePublications)" class="ui fluid selection dropdown">
                        <option :value="undefined">Publicações recentes</option>
                        <option v-for="project in projects" :key="project.key" :value="project">{{project.name}}</option>
                    </select>

                </div>
                <div class="field">

                    <select name="type" id="type" v-model="showType" class="ui fluid selection dropdown">
                        <option :value="undefined">Todos os tipos</option>
                        <option v-for="type in types" :key="type.type" :value="type">{{type.name}}</option>
                    </select>

                </div>
                <div class="field">

                    <div class="ui icon input">
                        <input type="text" placeholder="Pesquisar..." v-model="apiFilters.searchText" @keyup.enter="updateCloud">
                        <i class="search link icon"></i>
                    </div>
                    
                </div>
    
            </div>
        </div>
        

        <div class="ui segment">
            <div v-for="year in sortedYears" :key="year.number" class="years">
                <h2> {{ year.number }} </h2>
                <div class="publications">
                    <div class="publication ui card" v-for="publication in year.publications" :key="publication.key"
                        :class="publication.data.itemType">
                        <p class="content">
                            <span v-html="publication.citation"></span>
                            <span v-if="publication.data.DOI">DOI: {{publication.data.DOI}}.</span>
                        </p>
                        <div class="extra content">
                            <span v-if="publication.data.DOI">
                                <a :href="`https://doi.org/${publication.data.DOI}`" 
                                    target="_blank"
                                    class="ui icon basic button"
                                    title="Acessar via DOI"
                                >
                                    <i class="icon file outline"></i>
                                    DOI
                                </a>
                            </span>
                            <span v-if="publication.data.url">
                                <a target="_blank" :href="publication.data.url"
                                    class="ui icon basic button">
                                    <i class="icon linkify"></i>
                                    Acessar
                                </a>
                            </span>
                            <span v-if="!publication.data.url && !publication.data.DOI">
                                <a target="_blank" :href="`https://google.com.br/search?q=${publication.data.title}`"
                                    class="ui icon basic button"
                                >
                                    <i class="icon search"></i>
                                    Buscar
                                </a>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
            <div v-if="loading" class="ui active inverted dimmer">
                <div class="ui text loader">Buscando publicações...</div>
                <p></p>
            </div>
            <div v-if="!loading && publications.length == 0">Nenhuma publicação para estes filtros.</div>
            <button class="ui default button" @click="loadMore">Carregar mais publicações</button>

        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <script src="https://unpkg.com/axios@0.2.1/dist/axios.min.js"></script>
    <script src="https://unpkg.com/semantic-ui@2.3.1/dist/semantic.min.js"></script>

    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://unpkg.com/tinycolor2@1.4.1/dist/tinycolor-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tinygradient@1.1.4/browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jqcloud2@2.0.3/dist/jqcloud.min.js"></script>

    <script>

        const GROUP_ID = '4077554'
        const COLLECTION_ID = '83YIGLLI'

        const ITEMS_PER_REQUEST = 5

        const app = new Vue({
            el: '#app',
            data: {
                loading: false,
                groupId: GROUP_ID,
                years: {},
                projects: [],
                apiFilters: {
                    limit: 5,
                    sort: 'date',
                    searchText: ''
                },
                allowedTypes: [
                    { name: 'Artigos de Conferências', type: 'conferencePaper' },
                    { name: 'Artigos de Revistas', type: 'journalArticle' },
                    { name: 'Livros', type: 'book' },
                    { name: 'Capítulos de Livros', type: 'bookSection' },
                    { name: 'Monografias', type: 'thesis' },
                    { name: 'Blogs', type: 'blogPost' },
                ],
                selectedProject: undefined,
                showType: undefined,
                cache: {
                    recent: {
                        start: 0,
                        publications: []
                    }
                }
            },
            async created() {
                this.loading = true;
                try {
                    this.projects = (await getCollections(GROUP_ID))
                        .map(collection => collection.data)
                    this.initializeCaches()
                    await this.loadRecentPublications(this.replacePublications)
                    this.createCloud()
                    this.updateCloud()
                } finally {
                    this.loading = false;
                }
            },
            computed: {
                sortedYears() {
                    const sortedYears = Object.keys(this.years).sort().reverse().map(number => {
                        return {
                            number,
                            publications: this.years[number].publications
                        }
                    })

                    sortedYears.forEach(year => {
                        year.publications = year.publications.filter(p => this.filterPublication(p))
                    })

                    return sortedYears.filter(it => it.publications.length > 0)
                },
                notFiltering() {
                    return !this.filtering
                },
                filteringType() {
                    return this.showType !== undefined
                },
                filteringProject() {
                    return this.selectedProject !== undefined
                },
                filtering() {
                    return this.filteringType || this.filteringProject
                },
                publications() {
                    let result = []
                    for(let yearAndPublications of this.sortedYears) {
                        result = result.concat(yearAndPublications.publications)
                    }
                    return result
                },
                types() {
                    const types = this.publications.map(p => p.data.itemType)
                    return this.allowedTypes.filter(t => types.includes(t.type))
                },
                visiblePublications() {
                    return this.sortedYears.map(year => year.publications).flat()
                },
                joinedCloudText() {
                    return this.visiblePublications
                        .map((publication)=> abstractOf(publication) + ' ' + titleOf(publication))
                        .filter(text=>text.length > 0)
                        .join()
                },
                bestAbstractWords() {
                    const unusedWords = ['para','that','their','está','this','from','este','have','also','half','with','than','through','trazer','article','allows','mais','contexto','will']

                    return this.joinedCloudText.split(" ")
                        .filter(word => word.length > 3)
                        .filter(word =>
                            unusedWords.includes(word.toLowerCase()) == false
                        )
                },
                wordsQuantity() {
                    const words = {}

                    this.bestAbstractWords.forEach(word => {
                        if (!words[word]) {
                            words[word] = 1
                        } else {
                            words[word]++
                        }
                    })

                    return words
                },
                wordsWithWeight() {
                    const result = []

                    const wordsQuantity = this.wordsQuantity;

                    Object.keys(wordsQuantity).forEach(word => {
                        result.push({
                            text: word,
                            weight: wordsQuantity[word]
                        })
                    })

                    return result
                },
            },
            methods: {
                initializeCaches() {
                    this.projects.forEach(project=>{
                        if(!this.hasCacheFor(project))
                        {
                            this.cache[project.key] = { start: 0, publications: [] }
                        }
                    })
                },
                async loadMore() {
                    this.adjustStartParam()
                    this.loadPublications(this.appendPublications)
                },
                adjustStartParam() {
                    if(this.filteringProject) {
                        this.adjustStartParamFor(this.selectedProject)
                    } else {
                        this.adjustStartParamForRecentPublications()
                    }
                },
                adjustStartParamFor(project) {
                    const projectItemsCache = this.cache[project.key]
                    projectItemsCache.start += ITEMS_PER_REQUEST
                    projectItemsCache.updated = false
                },
                adjustStartParamForRecentPublications(){
                    this.cache.recent.start += ITEMS_PER_REQUEST
                    this.cache.recent.updated = false
                },
                async loadPublications(callback) {
                    if(this.filteringProject)
                        this.loadPublicationsFor(this.selectedProject, callback)
                    else
                        this.loadRecentPublications(callback)
                },
                async loadPublicationsFor(project, callback){
                    try {
                        this.loading = true
                        
                        const cache = this.cache[project.key]
                        
                        const start = cache.start
                        const limit = this.apiFilters.limit
                        const sort = this.apiFilters.sort
                        
                        if(cache.updated == false || cache.publications.length == 0)
                        {
                            const items = await getItems(GROUP_ID, project.key, start, limit, sort)
                            const publications = this.convertItemsIntoPublications(items)
                            cache.publications = publications
                            cache.updated = true
                        } 

                        const publications = cache.publications
                    
                        callback(publications)
                        
                        this.updateCloud()
                    } finally {
                        this.loading = false
                    }
                },
                hasCacheFor(project) {
                    return this.cache[project.key] != undefined
                },
                async loadRecentPublications(callback){
                    const start = this.cache.recent.start
                    const limit = this.apiFilters.limit
                    const sort = this.apiFilters.sort
                    const items = await getRecentItems(GROUP_ID, start, limit, sort)
                    
                    const publications = this.convertItemsIntoPublications(items)
                    
                    callback(publications)
                },
                convertItemsIntoPublications(items) {
                    const publications = filterPublications(items)
                    const attachments = filterAttachments(items)
                    linkPublicationsAndAttachments(publications, attachments)
                    return publications
                },
                replacePublications(publications){
                    this.years = groupByYear(publications)
                },
                appendPublications(publications) {
                    let newPublications = this.publications.concat(publications)
                    if(this.filteringProject)
                    {
                        this.cache[this.selectedProject.key].publications = newPublications
                    } else {
                        this.cache.recent.publications = newPublications
                    }
                    this.years = groupByYear(newPublications)
                },
                createCloud() {

                    const words = this.wordsWithWeight
                    if(words.length == 0) {
                        console.warn('No words to put in the cloud')
                        return;
                    }

                    $(document).ready(function () {
                        const gradient = tinygradient('#3b82a8','#c8c84a','#1f97af','#c75461').rgb(words.length)
                        $('#cloud').jQCloud(words, {
                            delay: 5,
                            autoResize: true,
                            colors: function (step) {
                                return gradient[words.length / step]
                            }
                        });
                    })
                },
                updateCloud() {
                    const words = this.wordsWithWeight
                    $('#cloud').jQCloud('update', words);
                },
                filterPublication(publication) {
                    if (this.filteringType)
                        if (typeOf(publication) != this.showType.type)
                            return false
                    if (this.filteringProject)
                        if (!isInProject(publication, this.selectedProject))
                            return false
                    if (this.apiFilters.searchText.length > 0) {
                        const text = publication.citation.toUpperCase()
                        const search = this.searchText.toUpperCase()
                        const notFound = text.indexOf(search) == -1
                        if (notFound)
                            return false
                    }
                    return true
                }
            }
        })
        async function getCollections(groupId) {
            return axios.get(`https://api.zotero.org/groups/${groupId}/collections`)
        }
        async function getRecentItems(groupId, start, limit, sort) {
            return axios.get(`https://api.zotero.org/groups/${groupId}/items?format=json&include=data,citation&style=associacao-brasileira-de-normas-tecnicas-note&start=${start}&limit=${limit}&sort=${sort}`)
        }
        async function getItems(groupId, collectionId, start, limit, sort) {
            return axios.get(`https://api.zotero.org/groups/${groupId}/collections/${collectionId}/items?format=json&include=data,citation&style=associacao-brasileira-de-normas-tecnicas-note&start=${start}&limit=${limit}&sort=${sort}`)
        }
        function filterPublications(items) {
            return items.filter(item => typeOf(item) != "attachment")
        }
        function filterAttachments(items) {
            return items.filter(item => typeOf(item) == "attachment")
        }
        function linkPublicationsAndAttachments(publications, attachments) {
            for (let publication of publications)
                addAttachmentsFor(publication, attachments)
        }
        function abstractOf(publication) {
            return publication.data.abstractNote
        }
        function titleOf(publication) {
            return publication.data.title
        }
        function typeOf(item) {
            return item.data.itemType
        }
        function areRelated(publication, attachment) {
            return keyOf(publication) == parentKey(attachment)
        }
        function isInProject(publication, project) {
            return publication.data.collections.indexOf(project.key) !== -1
        }
        function keyOf(item) {
            return item.key
        }
        function parentKey(item) {
            return item.data.parentItem
        }
        function addAttachmentsFor(publication, attachments) {
            publication.attachments = attachments.filter(attachment => areRelated(publication, attachment))
        }
        function attach(publication, attachment) {
            if (!publication.attachments)
                publication.attachments = []
            publication.attachments.push(attachment)
        }
        function getYearOf(publication) {
            const matches = publication.data.date.match(/\d{4}/g)
            if (matches && matches.length > 0)
                return new Number(matches[0])
            return "Sem ano"
        }
        function isNew(year, years) {
            return years[year] === undefined
        }
        function groupByYear(publications) {
            const years = {}
            for (let publication of publications) {
                const year = getYearOf(publication)
                if (isNew(year, years)) {
                    years[year] = {
                        publications: []
                    }
                }
                years[year].publications.push(publication)
            }
            return years;
        }
    </script>
</body>

</html>